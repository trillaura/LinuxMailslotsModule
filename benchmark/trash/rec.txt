Project - Linux Mail slots
This specification related the implementation of a special device file that is accessible according to FIFO style semantic (via open/close/read/write services), but offering an execution semantic of read/write services such that any segment that is posted to the stream associated with the file is seen as an independent data unit (a message), thus being posted and delivered atomically (all or nothing) and in data separation (with respect to other segments) to the reading threads.
The device file needs to be multi-instance (by having the possibility to manage at least 256 different instances) so that mutiple FIFO style streams (characterized by the above semantic) can be concurrently accessed by active processes/threads.

The device file needs to also support ioctl commands in order to define the run time behavior of any I/O session targeting it (such as whether read and/or write operations on a session need to be performed according to blocking or non-blocking rules).

Parameters that are left to the designer, which should be selected via reasonable policies, are:

the maximum size of managed data-units (this might also be made tunable via ioctl up to an absolute upper limit)
the maximum storage that can be (dynamically) reserved for any individual mail slot
the range of device file minor numbers supported by the driver (it could be the interval [0-255] or not)
NOTE: this project deals with implementing within Linux services similar to those that are offered by Windows "mail slots", which is the reason for the selected project name

+++++++++++++++++++++++

Special device file
- accessibile in base a fifo semantic - named pipe: in cui scritture/letture fifo su pipe con nome
- semantica fifo: se write di n byte in una fifo byte possono essere estratti tramite letture diverse (come da un file)

- semantica mail slot: byte scritti visti come segmenti indipendenti: alla scrittura stato del mail slot 	
	m byte rappresentano i primi m standing non oggetti individualmente consegnabili, ma messaggio unico; o estratto tutto o non estratto 
	- parametri estrazione coerenti se data taglia di standing message e standing segment pari a n richiesta di estrarre esattamente n altrimenti fallisce
	- se troppo piccolo buffer di lettura si richiedere iterativamente ingrandendo il buffer èer poter estrarre 
	- solo segmento standing solo un'unità letta alla volta

- rappresentazione data unit: memoria dinamica a livello kernel 
	
- sincronizzazione write e reader 

- istanza multipla dei messaggi completamente separate

head pointers in un array che puntano
- major number che porta su un certo driver codice che dentifica nodo 
- minor number che porta su una certa istanza è codice che identifica

256 istanze diverse di stream nel sistema, quindi mail slot

accessibilità secondo livello di concorrezna sia cross sessione (dato un processo e un nodo nel vfs, nodo associato a quel major e minor) che non

fd visibile a tutto il processo e a tutti i thread del procsso. Una volta aprte quell'istanza serve sincronizzarsi sul minor number su cui si sta operando

se fork processo fd valido anche sul processo figlio, 

entrando nel driver di operazioni controllo della sessione, il minor number  e redirezione lì per fare operazione atomica richiesta

nel driver supporto per basiche e ioctl, serve per controllare stato oggetto io che ha solo interfaccia definita la semantica dipende dal tipo di oggetto da controllare, prese info relative a inode e 
	1) definire se sessione di io lavora in modo non bloccante (se dati non disponibile read ritorna) o bloccante (read attende che vengano consegnati i dati, attraverso semafori lato kernel o conditional wait queues)
	2) cabmiare max taglia segmente che si consegna 
	3) massimo storage da riservare 


se reader in attesa erchè dati non disponibili, quando writer scrive reader svegliato potrebbe non essere compliant per andare a 

reader risvegliano reader in attesa se la lettura fallisce di uno sveglia chi ha richiesta standing compatibile

se writer non trova storage disponibile può essere svegliato dal reader 

sequenzializzate solo operazioni su mailslot (esempio buffer acquisito da userspace o ritornati all'utente fuori dalla sezione critica, dipenderà dallo scheduling)